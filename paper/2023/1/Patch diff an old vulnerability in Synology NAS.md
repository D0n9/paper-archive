# Patch diff an old vulnerability in Synology NAS
**作者：cq674350529  
本文为作者投稿，Seebug Paper 期待你的分享，凡经采用即有礼品相送！ 投稿邮箱：paper@seebug.org**

### 前言

之前在浏览群晖官方的安全公告时，翻到一个`Critical`级别的历史漏洞[Synology-SA-18:64](https://www.synology.com/en-global/security/advisory/Synology_SA_18_64)。根据漏洞公告，该漏洞存在于群晖的`DSM(DiskStation Manager)`中，允许远程的攻击者在受影响的设备上实现任意代码执行。对群晖`NAS`设备有所了解的读者可能知道，默认条件下能用来在群晖`NAS`上实现远程代码执行的漏洞很少，有公开信息的可能就是与`Pwn2Own`比赛相关的几个。由于该漏洞公告中没有更多的信息，于是打算通过补丁比对的方式来定位和分析该公告中提及的漏洞。

### 环境准备

群晖环境的搭建可参考之前的文章[《A Journey into Synology NAS 系列一: 群晖NAS介绍》](https://cq674350529.github.io/2021/08/30/A-Journey-into-Synology-NAS-%E7%B3%BB%E5%88%97%E4%B8%80-%E7%BE%A4%E6%99%96NAS%E4%BB%8B%E7%BB%8D/),这里不再赘述。根据群晖的[安全公告](https://www.synology.com/en-global/security/advisory/Synology_SA_18_64)，以`DSM 6.1`为例，`DSM 6.1.7-15284-3`以下的版本均受该漏洞影响，由于手边有一个`DSM 6.1.7`的虚拟机，故这里基于`DSM` `6.1.7-15284`版本进行分析。

### 补丁比对

首先对群晖的`DSM`更新版本进行简单说明，方便后续进行补丁比对。以`DSM 6.1.7`版本为例，根据其发行说明，存在`1`个大版本`6.1.7-15284`和`3`个小版本`6.1.7-15284 Update 1`、`6.1.7-15284 Update 2`及`6.1.7-15284 Update 3`。其中，大版本`6.1.7-15284`对应初始版本，其镜像文件中包含完整的系统文件，而后续更新的小版本则只包含与更新相关的文件。另外，`Update 2`版本中包含`Update 1`中的更新，`Update 3`中也包含`Update 2`中的更新，也就是说最后`1`个小版本`Update 3`包含了全部的更新。

从群晖官方的[镜像仓库](https://archive.synology.com/download/)中下载`6.1.7-15284`、`6.1.7-15284-2`和`6.1.7-15284-3`这三个版本对应的`pat`文件。在`Update x`版本的`pat`文件中除了包含与更新相关的模块外，还有一个描述文件`DSM-Security.json`。比对`6.1.7-15284-2`和`6.1.7-15284-3`这2个版本的描述文件，如下。

![](https://github.com/D0n9/paper_archive/blob/main/paper/picture/2023/1/0f929bb2-db24-48cd-ad22-4de3733e516d.png?raw=true)

可以看到，在`6.1.7-15284 Update 3`中更新的模块为`libfindhost`与`netatalk-3.x`，与对应版本发行说明中的信息一致。

![](https://github.com/D0n9/paper_archive/blob/main/paper/picture/2023/1/e55eb3dd-f26c-4c80-ad72-76971e4b3f4d.png?raw=true)

借助`Bindiff`插件对版本`6.1.7-15284`和`6.1.7-15284 Update 3`中的`libfindhost`模块进行比对，如下。可以看到，主要的差异在函数`FHOSTPacketRead()`中。后面的其他函数很短，基本上就`1~2`个`block`，可忽略。

![](https://github.com/D0n9/paper_archive/blob/main/paper/picture/2023/1/ee30e70b-51f3-4fb9-acdc-d9517579fa03.png?raw=true)

两个版本中函数`FHOSTPacketRead()`内的主要差异如下，其中在`6.1.7-15284 Update 3`中新增加了`3`个`block`。

![](https://github.com/D0n9/paper_archive/blob/main/paper/picture/2023/1/8af57a34-ff47-4e47-80ec-bd7dd78f0001.png?raw=true)

对应的伪代码如下。可以看到，在`6.1.7-15284 Update 3`中，主要增加了对变量`v34`的额外校验，而该变量会用在后续的函数调用中。因此，猜测漏洞与`v34`有关。

![](https://github.com/D0n9/paper_archive/blob/main/paper/picture/2023/1/f02ea8b1-1d27-48fc-98db-fb7bc5335254.png?raw=true)

### 漏洞分析

`libfindhost.so`主要是与`findhostd`服务相关，用于在局域网内通过`Synology Assistant`工具搜索、配置和管理对应的`NAS`设备，关于`findhostd`服务及协议格式可参考之前的文件[《A Journey into Synology NAS 系列二: findhostd服务分析》](https://cq674350529.github.io/2021/09/12/A-Journey-into-Synology-NAS-%E7%B3%BB%E5%88%97%E4%BA%8C-findhostd%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90/)。其中，发送数据包的开始部分为`magic (\x12\x34\x56\x78\x53\x59\x4e\x4f)`，剩余部分由一系列的`TLV`组成，`TLV`分别对应`pkt_id`、`data_length`和`data`。

另外，在`libfindhost.so`中存在一大段与协议格式相关的数据`grgfieldAttribs`，表明消息剩余部分的格式和含义。具体地，下图右侧中的每一行对应结构`pkt_item`，其包含`6`个字段。其中，`pkt_id`字段表明对应数据的含义，如数据包类型、用户名、`mac`地址等；`offset`字段对应将数据放到内部缓冲区的起始偏移；`max_length`字段则表示对应数据的最大长度。

> 实际上，`libfindhost.so`中的`grgfieldAttribs`，每一个`pkt_item`包含`8`个字段；而在`Synology Assistant`中，每一个`pkt_item`包含`6`个字段。不过，重点的字段应该是前几个，故这里暂且只关注前`6`个字段。

![](https://github.com/D0n9/paper_archive/blob/main/paper/picture/2023/1/fc5d6937-cfe1-4108-85a9-5710bd468786.png?raw=true)

`findhostd`进程会监听`9999/udp, 9998/udp, 9997/udp`等端口，其会调用`FHOSTPacketRead()`来对接收的数据包进行初步校验和解析。以`DSM 6.1.7-15284`版本为例， `FHOSTPacketRead()`的部分代码如下。首先，在`(1)`处会校验接收数据包的头部，校验通过的话程序流程会到达`(2)`，在`while`循环中依次对剩余部分的`pkt_item`进行处理。在`(2)`处会从数据包中读取对应的`pkt_id`，之后在`grgfieldAttribs`中通过二分法查找对应的`pkt_item`，查找成功的话程序流程会到达`(3)`。在`(3)`处会读取对应`pkt_item`中的`pkt_index`字段，如果`pkt_index=2`，程序流程会到达`(4)`。如果`v39 == pkt_id`，则会执行`++v36`，否则在`(5)`处会将`pkt_id`赋值给`v39`。之后，在`(6)`处会根据`pkt_index`的值调用相应的`FHOSTPacketReadXXX()`。

```
__int64 FHOSTPacketRead(__int64 a1, char *recv_data, int recv_data_size, char *dst_buf)
{
  v4 = a1;
   remain_pkt_len = recv_data_size;
   v6 = dst_buf;

  memset(dst_buf, 0, 0x2F50uLL);
  v7 = *(unsigned int *)FHOSTHeaderSize_ptr;
  v8 = *(_DWORD *)FHOSTHeaderSize_ptr;
   v37 = memcmp(recv_data, src, *(unsigned int *)FHOSTHeaderSize_ptr);     pkts_ptr = &recv_data[v7];
  v33 = pkts_ptr;
  v34 = remain_pkt_len - v8;
   v11 = v6 + 0x74;
  v12 = (char *)off_7FFFF7DD7FE0;    v38 = v6;
  v39 = 0;
  v36 = 0;
  s = v11;
  while ( 1 )
  {
    pkt_id = (unsigned __int8)*pkts_ptr;       v15 = pkts_ptr + 1;
    wrap_remain_pkt_len = remain_pkt_len - 1;
    v17 = 76LL;
    v18 = 0LL;
    wrap_pkt_id = (unsigned __int8)*pkts_ptr;
       pkt_index_in_table = *((_DWORD *)v21 + 1);        v31 = *((unsigned int *)v21 + 6);
    if ( (_DWORD)v31 != 2 )
      v31 = 1LL;
    if ( pkt_index_in_table == 2 )                 {
      if ( v39 == pkt_id )           {
        ++v36;           }
      else
      {
        v39 = (unsigned __int8)*pkts_ptr;          v36 = 0;
      }
    }
    else
    {
      v39 = 0;
      v36 = 0;
    }
    v24 = (*((__int64 (__fastcall **)(__int64, char *, _QWORD, char *, _QWORD, __int64, _QWORD))off_7FFFF7DD7FC0              + 3 * pkt_index_in_table
           + 1))(
            a1,
            pkts_ptr + 1,
            wrap_remain_pkt_len,
            &v38[*((_QWORD *)v21 + 1)],                    *((_QWORD *)v21 + 2),                          v31,
            v36); 
```

地址`off_7FFFF7DD7FC0`实际指向的内容如下。其中，函数`FHOSTPacketReadString()`会使用传入的第`7`个参数`v36`。另外，`FHOSTPacketReadArray()`内部直接调用`FHOSTPacketReadString()`，因此这两个函数是等价的。

```
LOAD:00007FFFF7DD7FC0 off_7FFFF7DD7FC0 dq offset grgfieldParsers

LOAD:00007FFFF7DD9340 grgfieldParsers dq 0                    ; DATA XREF: LOAD:off_7FFFF7DD7FC0↑o
LOAD:00007FFFF7DD9348                 dq offset FHOSTPacketReadString
LOAD:00007FFFF7DD9350                 dq offset FHOSTPacketWriteString
LOAD:00007FFFF7DD9358                 dq 1
LOAD:00007FFFF7DD9360                 dq offset FHOSTPacketReadInteger
LOAD:00007FFFF7DD9368                 dq offset FHOSTPacketWriteInteger
LOAD:00007FFFF7DD9370                 dq ?
LOAD:00007FFFF7DD9378                 dq offset FHOSTPacketReadArray
LOAD:00007FFFF7DD9380                 dq offset FHOSTPacketWriteArray
```

函数`FHOSTPacketReadString()`的部分代码如下。正常情况下，程序流程会到达`(7)`处，读取数据包中对应`data_length`字段，如果其值小于剩余数据包的总长度，程序流程会到达`(8)`。如果`(8)`处的条件成立，在`(9)`处会调用`snprintf()`将对应的`data`拷贝到内部缓冲区的指定偏移处，其中`snprintf()`的第`1`个参数为`(char *)(a4 + a7 * pkt_max_length)`，用到了传进来的`v36/a7`参数。

```
__int64 FHOSTPacketReadString(__int64 a1, _BYTE *a2, signed int remain_pkt_length, __int64 a4, unsigned __int64 pkt_max_length, __int64 a6, unsigned int a7)
{
   if ( remain_pkt_length > 0 )
  {
    data_length = (unsigned __int8)*a2;       v8 = 0;
    if ( remain_pkt_length > (int)data_length )
    {
      LOBYTE(v8) = 1;
      if ( *a2 )
      {
        LOBYTE(v8) = 0;
        if ( data_length < pkt_max_length )           {
          v8 = data_length + 1;
          snprintf((char *)(a4 + a7 * pkt_max_length), (int)data_length + 1, "%s", a2 + 1);           }
      }
    } 
```

回到前面的`(4)/(5)`处，可以发现，如果发送的数据包中包含多个对应`pkt_index=0x2`的`pkt_item`，如`pkt_id=0xbc/0xbd/0xbe/0xbf`，则可以触发多次`++v36`。由于缺乏对`v36`的适当校验，通过发送伪造的数据包，可造成后续在调用`FHOSTPacketReadString()`出现越界写。进一步地，在`(6)`处传递的`v38`与`FHOSTPacketRead()`函数的第`4`个参数有关，而在`findhostd`程序中调用`FHOSTPacketRead()`时第`4`个参数为指向栈上的缓冲区，因此，利用该越界写操作可覆盖栈上的返回地址，从而劫持程序的控制流。

> `DSM 6.1.7-15284`版本中的`findhostd`文件似乎经过混淆了，无法直接采用`IDA Pro`等工具进行分析，可以在`gdb`中`dump`出`findhostd`进程，然后对其进行分析。另外，在较新的版本如`VirtualDSM 6.2.4-25556`中，对应的`findhostd`文件未被混淆，可直接分析。

```
__int64 handler_recv_data(__int64 a1, __int64 a2, __int64 a3)
{
   int v124[3042];
   memset(v124, 0LL, 0x2F50LL);   if ( (int)FHOSTPacketRead((__int64)v113, a2, (unsigned int)a1, (__int64)v124) <= 0 )
  { 
```

另外，由于`Synology Assistant`客户端对协议数据包的处理过程与`findhostd`类似，因此其早期的版本也会受该漏洞影响。

### 漏洞利用

查看`findhostd`启用的缓解机制，如下，同时设备上的`ASLR`等级为`2`。其中，显示`"NX disabled"`，不知道是否和程序被混淆过有关。在设备上查看进程的内存地址空间映射，确实看到`[stack]`部分为`rwxp`。考虑到通用性，这里还是采用`ret2libc`的思路来获取设备的`root shell`。

```
$ checksec.exe --file ./findhostd
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
```

由于越界写发生在调用`snprintf()`时，故存在`'\x00'`截断的问题。通过调试发现，利用越界写覆盖栈上的返回地址后，在返回地址的不远处存在发送的原始数据包内容，因此可借助`stack pivot`将栈劫持到指向可控内容的地方，从而继续进行`rop`。

在实际进行利用的过程中，本来是想将`cmd`直接放在数据包中发送，然后定位到其在栈上的地址，再将其保存到`rdi`寄存器中，但由于未找到合适的`gadgets`，故采用将`cmd`写入`findhostd`进程的某个固定地址处的方式替代。同时，发现区域`0x00411000-0x00610000`不可写(正常应该包含`.bss`区域?)，而`.got.plt`区域可写，故将`cmd`写到了该区域。

```
root@NAS_6_1:/# cat /proc/`pidof findhostd`/maps
00400000-00411000 r-xp 00000000 00:00 0
00411000-00610000 ---p 00000000 00:00 0                                 # no writable permission 
00610000-00611000 r-xp 00000000 00:00 0
00611000-00637000 rwxp 00000000 00:00 0                       [heap]
00800000-00801000 rwxp 00000000 00:00 0
...
7ffffffde000-7ffffffff000 rwxp 00000000 00:00 0               [stack]   # executable stack?
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0       [vsyscall]
```

最终效果如下。

![](https://github.com/D0n9/paper_archive/blob/main/paper/picture/2023/1/d0e6cebf-dcf1-464b-b4c8-e3d12a693eda.gif?raw=true)

### One More Thing

获取到设备的`root shell`后，相当于获取了设备的控制权，比如可以查看用户共享文件夹中的文件等。但是如何登录设备的`Web`管理界面呢？这里给出一种简单的方案：利用`synouser`和`synogroup`命令增加`1`个管理员用户，然后使用新增的用户进行登录即可。当然，`synouser`命令支持直接更改现有用户的密码，且无需原密码，但改了之后正常用户就不知道其密码了 :(

```
# 增加一个用户名为cq, 密码为cq674350529的用户
$ synouser --add cq cq674350529 "test admin" 0 "" 31
# 查看当前管理员组中的现有用户
$ synogroup --get administrators
# 将新增加的用户cq添加到管理员组中，xxx为当前管理员组中的现有用户
$ synogroup --member administrators xxx xxx cq
# 之后, 便可利用该账户登录设备的Web管理界面
# 删除新增加的用户
$ synouser --del cq
```

### 小结

本文基于群晖`DSM 6.1.7-15284`版本，通过补丁比对的方式对群晖安全公告`Synology-SA-18:64`中提及的漏洞进行了定位和分析。该漏洞与`findhostd`服务相关，由于在处理接收的数据包时缺乏适当的校验，通过发送伪造的数据包，可触发`out-of-bounds write`，利用该操作可覆盖栈上的返回地址，从而劫持程序控制流，达到任意代码执行的目的。通常情况下，`findhostd`服务监听的端口不会直接暴露到外网，故该漏洞应该是在局域网内才能触发。

### 相关链接

*   [Synology Security Advisory: Synology-SA-18:64 DSM](https://www.synology.com/en-global/security/advisory/Synology_SA_18_64)
*   [群晖镜像仓库](https://archive.synology.com/download/)

* * *

![](https://github.com/D0n9/paper_archive/blob/main/paper/picture/2023/1/49d7439b-1963-4f7c-a1a1-8b60f49cf7ea.jpeg?raw=true)
 本文由 Seebug Paper 发布，如需转载请注明来源。本文地址：[https://paper.seebug.org/2038/](https://paper.seebug.org/2038/)